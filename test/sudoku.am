

fn sudoku_correct:
= sudoku ; true

fn sudoku_check:
= s check extract; reduce holds (map (\x -> (check (extract s x))) (for 0 8)) true

fn holds:
= a b ; and a b

fn sudoku_solve:
= s ; reduce holds 
        (map 
            (\x -> sudoku_check s (sudoku_line_valid) (x)) 
            [(at), (sudoku_col), (sudoku_block)]
        ) true


--sudoku_check s sudoku_line_valid --reduce holds (map (\x -> and (greater_equal x 0) (less_equal x 9)) [0,5,9,9,9]) true

--sudoku_check s sudoku_line_valid --line_valid (sudoku_line s 0)

fn sudoku_block:
= s 0 ; pblock s 0 0 3 3 []
= s 1 ; pblock s 3 0 3 3 []
= s 2 ; pblock s 6 0 3 3 []
= s 3 ; pblock s 0 3 3 3 []
= s 4 ; pblock s 3 3 3 3 []
= s 5 ; pblock s 6 3 3 3 []
= s 6 ; pblock s 0 6 3 3 []
= s 7 ; pblock s 3 6 3 3 []
= s 8 ; pblock s 6 6 3 3 []
= s _ ; []
-- private method
fn pblock:
= s _ _ _ 0 list ; list
= s x y c l list ; pblock s x (add y 1) c (sub l 1) (concat list (take c (drop x (at s y))))


fn substitue:
= sudoku number x y ; 1

fn sudoku_line:
= s i ; at s i

--| get a column of a nested list
fn sudoku_col:
= sudoku i ; pcol sudoku [] i
-- private method
fn pcol:
= [] c _ ; c
= (s:ss) c i ; pcol ss (append c (at s i)) i

--| replace an element in a list at the specified parameter
fn sudoku_rep:
= s i e ; prep s [] i e
-- private method
fn prep:
= [] r _ _ ; r
= (s:ss) r 0 e ; prep ss (append r e) (sub 0 1) e
= (s:ss) r i e ; prep ss (append r s) (sub i 1) e


-- if a malformed index is given this function most likley throws an error.
-- this is fair enough for a prototype.
--| get an element at the specified postion in a list
fn at:
= [] _ ; fatal "function 'at' could not extract with given index. that means that the index was out of bounds"
= (l:ls) 0 ; l
= (l:ls) i ; at ls (sub i 1)

-- a sudoku line is valid iff every number from 1 to 9 only occurs max once
fn sudoku_line_valid:
= line ; and (reduce holds (map (\x -> and (greater_equal x 0) (less_equal x 9)) line) true) (pline_valid line 1)
-- private method
fn pline_valid:
= list 10 ; true
= list i ; if less_equal (list_count_expr list i) 1 
           then pline_valid list (add i 1) 
           else false

fn list_count_expr:
= list e ; plist_count_expr list e 0
-- private method
fn plist_count_expr:
= [] _ i ; i
= (l:ls) e i ; if equal l e
                 then plist_count_expr ls e (add i 1)
                 else plist_count_expr ls e i

fn list_len:
= l ; plist_len l 0
fn plist_len:
= [] n ; n
= (l:ls) n ; plist_len ls (add n 1)

fn take:
= list a ; ptake list a []
-- private method
fn ptake:
= n [] list ; if greater_equal n 0
              then list
              else fatal "tried to take to much from a list"
= 0 (l:ls) list ; list
= n (l:ls) list ; if greater n 0
                  then ptake (sub n 1) ls (append list l)
                  else list

fn drop:
= _ [] ; []
= 0 list ; list
= n (l:ls) ; if greater n 0
             then drop (sub n 1) ls
             else cons l ls

fn concat:
= list [] ; list
= list (r:rs) ; concat (append list r) rs

fn reduce:
= f [] s ; s
= f (l:ls) s ; reduce f ls (f l s)

fn for:
= from to ; pfor from to []
fn pfor:
= from to l ; if equal from to
              then cons to l
              else pfor from (sub to 1) (cons to l)

fn map:
= f list ; pmap f list []
-- private method
fn pmap:
= _ [] list ; list
= f (l:ls) list ; pmap f ls (append list (f l))

fn main:
=; sudoku_solve [ [1,0,0,0,0,0,0,0,0]
                , [0,2,0,0,0,0,0,0,0]
                , [0,0,9,0,0,0,0,0,0]
                , [0,0,0,0,0,0,0,0,0]
                , [0,0,0,0,0,0,0,0,0]
                , [0,0,0,0,0,0,0,0,0]
                , [0,0,0,0,0,0,0,2,0]
                , [0,3,0,0,0,0,0,0,0]
                , [9,0,0,0,0,0,0,0,0]
                ]

